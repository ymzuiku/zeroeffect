# Base Usage

## Classic Component Pattern with Lifecycle

The recommended way to create components in zeroeffect is using the lifecycle pattern:

```typescript
import { h } from "zeroeffect";

const App = () => {
  // 1. Create element
  const div = h.div();

  // 2. Create state
  const state = {
    count: 0
  };

  // 3. Register lifecycle callbacks
  h.onUpdate(div, () => {
    console.log('on state update')
  });

  h.onMount(div, () => {
    console.log('on div mount')
  });

  h.onRemove(div, () => {
    console.log('on div remove')
  });

  // 4. Handle events
  const handleOnClick = () => {
    state.count++;
    h.update(state)
  };

  // 5. Bind reactive properties to the element
  return h.ref(div)([state], {
    class: 'primary',
    onclick: handleOnClick
  }, () => `Count: ${state.count}`);
}

document.body.append(App());
```

## Two Patterns for h.ref

### Pattern 1: Bind to Newly Created Element

```typescript
const div = h.div();
h.ref(div)(
  [state],
  { class: "title-lg" },
  () => `Count: ${state.count}`,
  h.span([state], () => (state.count % 2 === 0 ? "Even" : "Odd"))
);
```

### Pattern 2: Bind to Existing Element

```typescript
const existingDiv = document.createElement("div");
h.ref(existingDiv)(
  [other],
  { class: "text-blue" },
  () => `Name: ${other.name}`
);
```

## h.onUpdate Usage Patterns

### Pattern 1: Global Update Callback

```typescript
// Subscribe to all updates (returns unsubscribe function)
const unsubscribe = h.onUpdate(() => {
  console.log("Any state update!");
});

// Later: unsubscribe()
```

### Pattern 2: Element-Specific Callback with Lifecycle Management

```typescript
const div = h.div();
const state = { count: 0 };

// Register callback for this specific element
h.onUpdate(div, () => {
  console.log("Element updated!");
});

h.onMount(div, () => {
  console.log("Element mounted!");
});

h.onRemove(div, () => {
  console.log("Element removed!");
});

// Bind reactive properties
return h.ref(div)([state], {
  onclick: () => {
    state.count++;
    h.update(state);
  }
}, () => `Count: ${state.count}`);
```

## h.if Usage Patterns

### Basic Conditional Rendering

```typescript
// Simple conditional rendering
const state = { show: true };
const visible = h.if(
  [state],
  () => state.show,
  () => h.div("Content is visible")
);

// With else clause
const state2 = { isLoggedIn: false };
const content = h.if(
  [state2],
  () => state2.isLoggedIn,
  () => h.div("Welcome back!"),  // True branch
  () => h.div("Please log in")   // False branch
);
```

### Nested Conditionals

```typescript
const state = { outer: true, inner: false };
const nested = h.if(
  [state],
  () => state.outer,
  () => h.if(
    [state],
    () => state.inner,
    () => h.div("Both conditions true"),
    () => h.div("Inner condition false")
  )
);
```

### Conditional with Event Handlers

```typescript
const state = { isExpanded: false };
const toggleContent = h.if(
  [state],
  () => state.isExpanded,
  () => h.div(
    { class: "expanded-content" },
    "Expanded content",
    h.button({
      onclick: () => {
        state.isExpanded = false;
        h.update(state);
      }
    }, "Collapse")
  ),
  () => h.button({
    onclick: () => {
      state.isExpanded = true;
      h.update(state);
    }
  }, "Expand")
);
```

### Key Characteristics

- **Initial placeholder**: Returns a span element that gets replaced based on condition
- **Conditional caching**: Re-renders only when condition value actually changes
- **Hidden fallback**: Returns hidden span when condition is false and no else provided

## h.list Usage Patterns

### Basic List Rendering

```typescript
// Simple list
const list = [1, 2, 3];
const listElement = h.list(
  list,
  (value) => h.div(`Item: ${value}`)
);

// With index
const items = ['a', 'b', 'c'];
const numberedList = h.list(
  items,
  (value, index) => h.div(`${index + 1}. ${value}`)
);
```

### Complex Object Lists

```typescript
const todos = [
  { id: 1, text: 'Learn TypeScript', completed: false },
  { id: 2, text: 'Practice zeroeffect', completed: true },
  { id: 3, text: 'Build app', completed: false }
];

const todoList = h.list(
  todos,
  (todo) => h.div(
    { class: 'todo-item' },
    h.input({
      type: 'checkbox',
      checked: () => todo.completed,
      onchange: () => {
        todo.completed = !todo.completed;
        h.update(todo);
      }
    }),
    h.span(() => todo.text)
  )
);
```

### Nested Lists

```typescript
const categories = [
  { name: 'Fruits', items: ['Apple', 'Banana', 'Orange'] },
  { name: 'Vegetables', items: ['Carrot', 'Celery', 'Lettuce'] }
];

const categoryList = h.list(
  categories,
  (category) => h.div(
    h.h3(() => category.name),
    h.ul(
      h.list(
        category.items,
        (item) => h.li(() => item)
      )
    )
  )
);
```

### Reactive List Items

```typescript
const state = { filter: 'all' };
const items = [
  { id: 1, text: 'Task 1', category: 'work' },
  { id: 2, text: 'Task 2', category: 'personal' },
  { id: 3, text: 'Task 3', category: 'work' }
];

const filteredList = h.list(
  items,
  (item) => h.div(
    [state, item],  // Multiple dependencies
    () => `${item.text} (${item.category}) - ${state.filter}`
  )
);
```

### List Operations (Add/Remove)

```typescript
const list = [1, 2, 3, 4, 5];

// Add item
const addItem = () => {
  list.push(list.length + 1);
  h.update(list);
};

// Remove item
const removeItem = (index: number) => {
  list.splice(index, 1);
  h.update(list);
};

// Clear list
const clearList = () => {
  list.length = 0;
  h.update(list);
};
```

### Styled List Items

```typescript
const users = [
  { id: 1, name: 'Alice', active: true },
  { id: 2, name: 'Bob', active: false },
  { id: 3, name: 'Charlie', active: true }
];

const userList = h.list(
  users,
  (user) => h.div(
    [user],
    {
      style: () => ({
        backgroundColor: user.active ? '#4CAF50' : '#ccc',
        padding: '10px',
        margin: '5px',
        borderRadius: '4px'
      }),
      class: 'user-item'
    },
    () => user.name
  )
);
```

### Virtual List (Large Datasets)

```typescript
const largeList = Array.from({ length: 10000 }, (_, i) => ({
  id: i,
  title: `Item ${i}`,
  description: `Description for item ${i}`
}));

const virtualContainer = h.virtualList(
  largeList,
  { style: { height: '500px', overflow: 'auto' } },
  (item) => h.div(
    { style: { padding: '10px', borderBottom: '1px solid #eee' } },
    h.h4(() => item.title),
    h.p(() => item.description)
  ),
  {
    itemHeight: 60,  // Fixed height
    overscan: 10     // Buffer items
  }
);
```

### Key Characteristics

- **Efficient updates**: Re-renders only when list length changes
- **Differential rendering**: Adds new items without re-rendering all items
- **Empty list handling**: Returns hidden span placeholder for empty arrays
- **TypeScript generics**: Full type inference support
- **Reactive items**: List items can have their own dependencies

## Important Notes

- **Don't call h.update() inside h.onUpdate callbacks** - This causes circular calls!
- **Lifecycle hooks provide complete component lifecycle**: onMount → onUpdate → onRemove
- **h.ref binds reactive properties** to both new and existing DOM elements
- **Automatic cleanup**: Element-specific callbacks auto-unsubscribe when element is removed

---

# Testing Standards for Interactive Elements

When creating interactive elements or components with event handlers (onclick, onchange, onkeydown, etc.), you MUST follow these guidelines:

## 1. Add data-testid Attribute

All interactive elements must include a `data-testid` attribute to enable testing.

```typescript
// ✓ Good - Has data-testid
h.button({
  'data-testid': 'todo-add-button',
  onclick: () => {
    // Add todo logic
  }
}, "Add Todo")

// ✗ Bad - Missing data-testid
h.button({
  onclick: () => {
    // Add todo logic
  }
}, "Add Todo")
```

## 2. Descriptive testid Naming

The `data-testid` value should be descriptive and follow this pattern:

- Use kebab-case (lowercase with hyphens)
- Include the component/action context
- Be specific about the element's function

```typescript
// ✓ Good examples
h.button({ 'data-testid': 'todo-item-delete-btn' }, "Delete")
h.input({ 'data-testid': 'todo-text-input' })
h.input({ 'data-testid': 'todo-checkbox' })
h.button({ 'data-testid': 'virtual-list-add-item' })

// ✗ Bad examples
h.button({ 'data-testid': 'btn1' }, "Click")
h.input({ 'data-testid': 'input1' })
h.div({ 'data-testid': 'item' })
```

## 3. Include Context in testid

When multiple similar elements exist, include context in the testid:

```typescript
// ✓ Good - Context is clear
h.button({ 'data-testid': 'todo-list-clear-all-btn' }, "Clear All")
h.button({ 'data-testid': 'todo-item-edit-btn' }, "Edit")

// ✗ Bad - No context
h.button({ 'data-testid': 'clear-btn' }, "Clear All")
h.button({ 'data-testid': 'edit-btn' }, "Edit")
```

## 4. Common Interactive Elements

All these elements MUST have `data-testid`:

- Buttons (onclick handlers)
- Input fields (oninput, onkeydown, onchange handlers)
- Checkboxes (onchange handlers)
- Select dropdowns (onchange handlers)
- Textareas (oninput, onkeydown handlers)
- Any element with event handlers

## 5. Example: Todo List

```typescript
const todoList = h.list(
  todos,
  (todo) =>
    h.div(
      {
        'data-testid': 'todo-item',
        onclick: () => handleClick(todo)
      },
      h.input({
        'data-testid': 'todo-checkbox',
        type: "checkbox",
        checked: () => todo.completed,
        onchange: () => toggleTodo(todo)
      }),
      h.span(
        { 'data-testid': 'todo-text' },
        () => todo.text
      ),
      h.button(
        { 'data-testid': 'todo-delete-btn' },
        "Delete"
      )
    )
)
```

## Why This Matters

1. **Testing**: Enables automated testing with tools like Playwright, Cypress, or Selenium
2. **Accessibility**: Helps QA teams identify interactive elements
3. **Maintenance**: Makes code easier to debug and maintain
4. **Documentation**: Serves as inline documentation of element purposes

## Lint Rule

This will be enforced during code reviews. Elements with event handlers must have `data-testid` attributes.

## Lifecycle Management

### Memory Safety

zeroeffect uses WeakMap/WeakSet for automatic memory management:

```typescript
// ✓ Good - Automatic cleanup
const unsubscribe = h.onUpdate(() => {
  // This will be automatically cleaned up when the element is removed
});

// ✗ Bad - Memory leak
h.onUpdate(() => {
  // No way to unsubscribe
});
```

### Lifecycle Hooks

Use lifecycle hooks for component initialization and cleanup:

```typescript
const element = h.div("Content");

// 1. onMount - Called when element is added to DOM
const unsubscribeMount = h.onMount(element, () => {
  console.log("Mounted!");
  // Setup timers, event listeners, etc.
});

// 2. onUpdate - Called on every update
const unsubscribeUpdate = h.onUpdate(element, () => {
  console.log("Updated!");
});

// 3. onRemove - Called when element is removed from DOM
const unsubscribeRemove = h.onRemove(element, () => {
  console.log("Removed!");
  // Cleanup timers, remove event listeners, etc.
});

// Manual cleanup
unsubscribeMount();
unsubscribeUpdate();
unsubscribeRemove();
```

### Combined Lifecycle with onUpdate

For element-specific updates that auto-cleanup:

```typescript
// onUpdate with element automatically unsubscribes when element is removed
const unsubscribe = h.onUpdate(element, () => {
  // This callback will stop firing when element is removed
  console.log("Element updated!");
});

// No need to manually track removal - it's automatic
```

### Global Updates

Subscribe to all updates without element binding:

```typescript
// Global update listener (not tied to specific element)
const unsubscribe = h.onUpdate(() => {
  console.log("Any state update!");
});

// Unsubscribe when done
unsubscribe();
```

## Key Principles

1. **Always unsubscribe**: Every `h.onUpdate()` returns an unsubscribe function
2. **Use onRemove for cleanup**: Clean up resources in `onRemove` callbacks
3. **Let WeakMap handle memory**: Elements are automatically garbage collected
4. **Test lifecycle**: Verify mount/update/remove callbacks work correctly
