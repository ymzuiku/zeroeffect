# Base Usage

## Classic Component Pattern with Lifecycle

The recommended way to create components in zeroeffect is using the lifecycle pattern:

```typescript
import { h } from "zeroeffect";

const App = () => {
  // 1. Create element
  const div = h.div();

  // 2. Create state
  const state = {
    count: 0
  };

  // 3. Register lifecycle callbacks
  h.onUpdate(div, () => {
    console.log('on state update')
  });

  h.onMount(div, () => {
    console.log('on div mount')
  });

  h.onRemove(div, () => {
    console.log('on div remove')
  });

  // 4. Handle events
  const handleOnClick = () => {
    state.count++;
    h.update(state)
  };

  // 5. Bind reactive properties to the element
  return h.ref(div)([state], {
    class: 'primary',
    onclick: handleOnClick
  }, () => `Count: ${state.count}`);
}

document.body.append(App());
```

## Two Patterns for h.ref

### Pattern 1: Bind to Newly Created Element

```typescript
const div = h.div();
h.ref(div)(
  [state],
  { class: "title-lg" },
  () => `Count: ${state.count}`,
  h.span([state], () => (state.count % 2 === 0 ? "Even" : "Odd"))
);
```

### Pattern 2: Bind to Existing Element

```typescript
const existingDiv = document.createElement("div");
h.ref(existingDiv)(
  [other],
  { class: "text-blue" },
  () => `Name: ${other.name}`
);
```

## h.onUpdate Usage Patterns

### Pattern 1: Global Update Callback

```typescript
// Subscribe to all updates (returns unsubscribe function)
const unsubscribe = h.onUpdate(() => {
  console.log("Any state update!");
});

// Later: unsubscribe()
```

### Pattern 2: Element-Specific Callback with Lifecycle Management

```typescript
const div = h.div();
const state = { count: 0 };

// Register callback for this specific element
h.onUpdate(div, () => {
  console.log("Element updated!");
});

h.onMount(div, () => {
  console.log("Element mounted!");
});

h.onRemove(div, () => {
  console.log("Element removed!");
});

// Bind reactive properties
return h.ref(div)([state], {
  onclick: () => {
    state.count++;
    h.update(state);
  }
}, () => `Count: ${state.count}`);
```

## Important Notes

- **Don't call h.update() inside h.onUpdate callbacks** - This causes circular calls!
- **Lifecycle hooks provide complete component lifecycle**: onMount → onUpdate → onRemove
- **h.ref binds reactive properties** to both new and existing DOM elements
- **Automatic cleanup**: Element-specific callbacks auto-unsubscribe when element is removed

---

# Testing Standards for Interactive Elements

When creating interactive elements or components with event handlers (onclick, onchange, onkeydown, etc.), you MUST follow these guidelines:

## 1. Add data-testid Attribute

All interactive elements must include a `data-testid` attribute to enable testing.

```typescript
// ✓ Good - Has data-testid
h.button({
  'data-testid': 'todo-add-button',
  onclick: () => {
    // Add todo logic
  }
}, "Add Todo")

// ✗ Bad - Missing data-testid
h.button({
  onclick: () => {
    // Add todo logic
  }
}, "Add Todo")
```

## 2. Descriptive testid Naming

The `data-testid` value should be descriptive and follow this pattern:

- Use kebab-case (lowercase with hyphens)
- Include the component/action context
- Be specific about the element's function

```typescript
// ✓ Good examples
h.button({ 'data-testid': 'todo-item-delete-btn' }, "Delete")
h.input({ 'data-testid': 'todo-text-input' })
h.input({ 'data-testid': 'todo-checkbox' })
h.button({ 'data-testid': 'virtual-list-add-item' })

// ✗ Bad examples
h.button({ 'data-testid': 'btn1' }, "Click")
h.input({ 'data-testid': 'input1' })
h.div({ 'data-testid': 'item' })
```

## 3. Include Context in testid

When multiple similar elements exist, include context in the testid:

```typescript
// ✓ Good - Context is clear
h.button({ 'data-testid': 'todo-list-clear-all-btn' }, "Clear All")
h.button({ 'data-testid': 'todo-item-edit-btn' }, "Edit")

// ✗ Bad - No context
h.button({ 'data-testid': 'clear-btn' }, "Clear All")
h.button({ 'data-testid': 'edit-btn' }, "Edit")
```

## 4. Common Interactive Elements

All these elements MUST have `data-testid`:

- Buttons (onclick handlers)
- Input fields (oninput, onkeydown, onchange handlers)
- Checkboxes (onchange handlers)
- Select dropdowns (onchange handlers)
- Textareas (oninput, onkeydown handlers)
- Any element with event handlers

## 5. Example: Todo List

```typescript
const todoList = h.list(
  todos,
  (todo) =>
    h.div(
      {
        'data-testid': 'todo-item',
        onclick: () => handleClick(todo)
      },
      h.input({
        'data-testid': 'todo-checkbox',
        type: "checkbox",
        checked: () => todo.completed,
        onchange: () => toggleTodo(todo)
      }),
      h.span(
        { 'data-testid': 'todo-text' },
        () => todo.text
      ),
      h.button(
        { 'data-testid': 'todo-delete-btn' },
        "Delete"
      )
    )
)
```

## Why This Matters

1. **Testing**: Enables automated testing with tools like Playwright, Cypress, or Selenium
2. **Accessibility**: Helps QA teams identify interactive elements
3. **Maintenance**: Makes code easier to debug and maintain
4. **Documentation**: Serves as inline documentation of element purposes

## Lint Rule

This will be enforced during code reviews. Elements with event handlers must have `data-testid` attributes.

## Lifecycle Management

### Memory Safety

zeroeffect uses WeakMap/WeakSet for automatic memory management:

```typescript
// ✓ Good - Automatic cleanup
const unsubscribe = h.onUpdate(() => {
  // This will be automatically cleaned up when the element is removed
});

// ✗ Bad - Memory leak
h.onUpdate(() => {
  // No way to unsubscribe
});
```

### Lifecycle Hooks

Use lifecycle hooks for component initialization and cleanup:

```typescript
const element = h.div("Content");

// 1. onMount - Called when element is added to DOM
const unsubscribeMount = h.onMount(element, () => {
  console.log("Mounted!");
  // Setup timers, event listeners, etc.
});

// 2. onUpdate - Called on every update
const unsubscribeUpdate = h.onUpdate(element, () => {
  console.log("Updated!");
});

// 3. onRemove - Called when element is removed from DOM
const unsubscribeRemove = h.onRemove(element, () => {
  console.log("Removed!");
  // Cleanup timers, remove event listeners, etc.
});

// Manual cleanup
unsubscribeMount();
unsubscribeUpdate();
unsubscribeRemove();
```

### Combined Lifecycle with onUpdate

For element-specific updates that auto-cleanup:

```typescript
// onUpdate with element automatically unsubscribes when element is removed
const unsubscribe = h.onUpdate(element, () => {
  // This callback will stop firing when element is removed
  console.log("Element updated!");
});

// No need to manually track removal - it's automatic
```

### Global Updates

Subscribe to all updates without element binding:

```typescript
// Global update listener (not tied to specific element)
const unsubscribe = h.onUpdate(() => {
  console.log("Any state update!");
});

// Unsubscribe when done
unsubscribe();
```

## Key Principles

1. **Always unsubscribe**: Every `h.onUpdate()` returns an unsubscribe function
2. **Use onRemove for cleanup**: Clean up resources in `onRemove` callbacks
3. **Let WeakMap handle memory**: Elements are automatically garbage collected
4. **Test lifecycle**: Verify mount/update/remove callbacks work correctly
